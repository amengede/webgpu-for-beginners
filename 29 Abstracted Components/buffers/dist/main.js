(()=>{"use strict";var e,t,n,i,r={927:(e,t,n)=>{n.a(e,(async(e,t)=>{try{var i=n(127),r=n(543);const e=document.getElementById("gfx-main"),s=document.getElementById("sphere-count"),a=new i.Z;await a.make_scene(),s.innerText=a.triangles.length.toString();const o=new r.A(e,a);await o.Initialize(),t()}catch(e){t(e)}}),1)},543:(e,t,n)=>{n.d(t,{A:()=>a});class i{async initialize(e,t){for(var n=new Array(6),i=0;i<6;i++){const e=await fetch(t[i]),r=await e.blob();n[i]=await createImageBitmap(r)}await this.loadImageBitmaps(e,n),this.view=this.texture.createView({format:"rgba8unorm",dimension:"cube",aspect:"all",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:0,arrayLayerCount:6}),this.sampler=e.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"nearest",mipmapFilter:"nearest",maxAnisotropy:1})}async loadImageBitmaps(e,t){const n={dimension:"2d",size:{width:t[0].width,height:t[0].height,depthOrArrayLayers:6},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT};this.texture=e.createTexture(n);for(var i=0;i<6;i++)e.queue.copyExternalImageToTexture({source:t[i]},{texture:this.texture,origin:[0,0,i]},[t[i].width,t[i].height])}}class r{constructor(e,t){this.device=e,this.visibility=t,this.entries=new Array,this.binding=0}addImage2D(){this.visibility==GPUShaderStage.COMPUTE?(this.entries.push({binding:this.binding,visibility:this.visibility,storageTexture:{access:"write-only",format:"rgba8unorm",viewDimension:"2d"}}),this.binding+=1):(this.entries.push({binding:this.binding,visibility:this.visibility,sampler:{}}),this.binding+=1,this.entries.push({binding:this.binding,visibility:GPUShaderStage.FRAGMENT,texture:{}}),this.binding+=1)}addBuffer(e){this.entries.push({binding:this.binding,visibility:this.visibility,buffer:{type:e,hasDynamicOffset:!1}}),this.binding+=1}addImageCube(){this.entries.push({binding:this.binding,visibility:this.visibility,texture:{viewDimension:"cube"}}),this.binding+=1,this.entries.push({binding:this.binding,visibility:this.visibility,sampler:{}}),this.binding+=1}async makeBindGroupLayout(){this.bind_group_layout=this.device.createBindGroupLayout({entries:this.entries})}async build(e,t){const n=this.device.createPipelineLayout({bindGroupLayouts:[this.bind_group_layout]});this.visibility==GPUShaderStage.COMPUTE?this.pipeline=this.device.createComputePipeline({layout:n,compute:{module:this.device.createShaderModule({code:e}),entryPoint:t[0]}}):this.pipeline=this.device.createRenderPipeline({layout:n,vertex:{module:this.device.createShaderModule({code:e}),entryPoint:t[0]},fragment:{module:this.device.createShaderModule({code:e}),entryPoint:t[1],targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}})}}class s{constructor(e,t,n){this.device=e,this.usage=t,this.hostMemory=new Float32Array(n)}async Initialize(){const e={size:4*this.hostMemory.length,usage:this.usage};this.deviceMemory=this.device.createBuffer(e)}blit(e,t){for(let n=0;n<e.length;n++)this.hostMemory[t+n]=e[n]}upload(){this.device.queue.writeBuffer(this.deviceMemory,0,this.hostMemory,0,this.hostMemory.length)}}class a{constructor(e,t){this.render=()=>{let e=performance.now();this.scene.update(this.frametime),this.prepareScene();const t=this.device.createCommandEncoder(),n=t.beginComputePass();n.setPipeline(this.ray_tracing_pipeline.pipeline),n.setBindGroup(0,this.ray_tracing_bind_group),n.dispatchWorkgroups(this.canvas.width/8,this.canvas.height/8,1),n.end();const i=this.context.getCurrentTexture().createView(),r=t.beginRenderPass({colorAttachments:[{view:i,clearValue:{r:.5,g:0,b:.25,a:1},loadOp:"clear",storeOp:"store"}]});r.setPipeline(this.screen_pipeline.pipeline),r.setBindGroup(0,this.screen_bind_group),r.draw(6,1,0,0),r.end(),this.device.queue.submit([t.finish()]),this.device.queue.onSubmittedWorkDone().then((()=>{let t=performance.now();this.frametime=t-e;let n=document.getElementById("render-time");n&&(n.innerText=this.frametime.toString())})),requestAnimationFrame(this.render)},this.canvas=e,this.scene=t}async Initialize(){await this.setupDevice(),this.ray_tracing_pipeline=new r(this.device,GPUShaderStage.COMPUTE),this.screen_pipeline=new r(this.device,GPUShaderStage.FRAGMENT),await this.makeBindGroupLayouts(),await this.createAssets(),await this.makeBindGroups(),await this.makePipelines(),this.frametime=16,this.loaded=!1,this.render()}async setupDevice(){var e,t;this.adapter=await(null===(e=navigator.gpu)||void 0===e?void 0:e.requestAdapter()),this.device=await(null===(t=this.adapter)||void 0===t?void 0:t.requestDevice()),this.context=this.canvas.getContext("webgpu"),this.format="bgra8unorm",this.context.configure({device:this.device,format:this.format,alphaMode:"opaque"})}async makeBindGroupLayouts(){this.ray_tracing_pipeline.addImage2D(),this.ray_tracing_pipeline.addBuffer("uniform"),this.ray_tracing_pipeline.addBuffer("read-only-storage"),this.ray_tracing_pipeline.addBuffer("read-only-storage"),this.ray_tracing_pipeline.addBuffer("read-only-storage"),this.ray_tracing_pipeline.addBuffer("read-only-storage"),this.ray_tracing_pipeline.addBuffer("read-only-storage"),this.ray_tracing_pipeline.addImageCube(),await this.ray_tracing_pipeline.makeBindGroupLayout(),this.screen_pipeline.addImage2D(),await this.screen_pipeline.makeBindGroupLayout()}async createAssets(){this.color_buffer=this.device.createTexture({size:{width:this.canvas.width,height:this.canvas.height},format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.color_buffer_view=this.color_buffer.createView(),this.sampler=this.device.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"nearest",mipmapFilter:"nearest",maxAnisotropy:1}),this.sceneParameters=new s(this.device,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,16),this.sceneParameters.Initialize(),this.triangleBuffer=new s(this.device,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,28*this.scene.triangles.length),this.triangleBuffer.Initialize(),this.nodeBuffer=new s(this.device,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,8*this.scene.nodes.length),this.nodeBuffer.Initialize(),this.blasDescriptionBuffer=new s(this.device,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,20*this.scene.blasDescriptions.length),this.blasDescriptionBuffer.Initialize(),this.triangleIndexBuffer=new s(this.device,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.scene.triangles.length),this.triangleIndexBuffer.Initialize(),this.blasIndexBuffer=new s(this.device,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.scene.blasIndices.length),this.blasIndexBuffer.Initialize(),this.sky_texture=new i,await this.sky_texture.initialize(this.device,["dist/gfx/sky_front.png","dist/gfx/sky_back.png","dist/gfx/sky_left.png","dist/gfx/sky_right.png","dist/gfx/sky_bottom.png","dist/gfx/sky_top.png"])}async makeBindGroups(){this.ray_tracing_bind_group=this.device.createBindGroup({layout:this.ray_tracing_pipeline.bind_group_layout,entries:[{binding:0,resource:this.color_buffer_view},{binding:1,resource:{buffer:this.sceneParameters.deviceMemory}},{binding:2,resource:{buffer:this.triangleBuffer.deviceMemory}},{binding:3,resource:{buffer:this.nodeBuffer.deviceMemory}},{binding:4,resource:{buffer:this.blasDescriptionBuffer.deviceMemory}},{binding:5,resource:{buffer:this.triangleIndexBuffer.deviceMemory}},{binding:6,resource:{buffer:this.blasIndexBuffer.deviceMemory}},{binding:7,resource:this.sky_texture.view},{binding:8,resource:this.sky_texture.sampler}]}),this.screen_bind_group=this.device.createBindGroup({layout:this.screen_pipeline.bind_group_layout,entries:[{binding:0,resource:this.sampler},{binding:1,resource:this.color_buffer_view}]})}async makePipelines(){await this.ray_tracing_pipeline.build("struct Sphere {\n    center: vec3<f32>,\n    color: vec3<f32>,\n    radius: f32,\n}\n\nstruct Triangle {\n    corner_a: vec3<f32>,\n    //float\n    normal_a: vec3<f32>,\n    //float\n    corner_b: vec3<f32>,\n    //float\n    normal_b: vec3<f32>,\n    //float\n    corner_c: vec3<f32>,\n    //float\n    normal_c: vec3<f32>,\n    //float\n    color: vec3<f32>,\n    //float\n}\n\nstruct ObjectData {\n    triangles: array<Triangle>,\n}\n\nstruct Node {\n    minCorner: vec3<f32>,\n    leftChild: f32,\n    maxCorner: vec3<f32>,\n    primitiveCount: f32,\n}\n\nstruct blasDescription {\n    inverseModel: mat4x4<f32>,\n    rootNodeIndex: vec4<f32>,\n}\n\nstruct BVH {\n    nodes: array<Node>,\n}\n\nstruct blasDescriptions {\n    descriptions: array<blasDescription>,\n}\n\nstruct ObjectIndices {\n    primitiveIndices: array<f32>,\n}\n\nstruct Ray {\n    direction: vec3<f32>,\n    origin: vec3<f32>,\n}\n\nstruct SceneData {\n    cameraPos: vec3<f32>,\n    cameraForwards: vec3<f32>,\n    cameraRight: vec3<f32>,\n    maxBounces: f32,\n    cameraUp: vec3<f32>,\n}\n\nstruct RenderState {\n    color: vec3<f32>,\n    t: f32,\n    normal: vec3<f32>,\n    hit: bool,\n}\n\n@group(0) @binding(0) var color_buffer: texture_storage_2d<rgba8unorm, write>;\n@group(0) @binding(1) var<uniform> scene: SceneData;\n@group(0) @binding(2) var<storage, read> objects: ObjectData;\n@group(0) @binding(3) var<storage, read> tree: BVH;\n@group(0) @binding(4) var<storage, read> blas: blasDescriptions;\n@group(0) @binding(5) var<storage, read> triangleLookup: ObjectIndices;\n@group(0) @binding(6) var<storage, read> blasLookup: ObjectIndices;\n@group(0) @binding(7) var skyTexture: texture_cube<f32>;\n@group(0) @binding(8) var skySampler: sampler;\n\n@compute @workgroup_size(8,8,1)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n\n    let screen_size: vec2<i32> = vec2<i32>(textureDimensions(color_buffer));\n    let screen_pos : vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));\n\n    let horizontal_coefficient: f32 = (f32(screen_pos.x) - f32(screen_size.x) / 2) / f32(screen_size.x);\n    let vertical_coefficient: f32 = (f32(screen_pos.y) - f32(screen_size.y) / 2) / f32(screen_size.x);\n\n    let forwards: vec3<f32> = scene.cameraForwards;\n    let right: vec3<f32> = scene.cameraRight;\n    let up: vec3<f32> = scene.cameraUp;\n\n    var myRay: Ray;\n    myRay.direction = normalize(forwards + horizontal_coefficient * right + vertical_coefficient * up);\n    myRay.origin = scene.cameraPos;\n\n    let pixel_color : vec3<f32> = rayColor(myRay);\n\n    textureStore(color_buffer, screen_pos, vec4<f32>(pixel_color, 1.0));\n}\n\nfn rayColor(ray: Ray) -> vec3<f32> {\n\n    var color: vec3<f32> = vec3(1.0, 1.0, 1.0);\n    var result: RenderState;\n\n    var world_ray: Ray;\n    world_ray.origin = ray.origin;\n    world_ray.direction = ray.direction;\n\n    let bounces: u32 = u32(scene.maxBounces);\n    for(var bounce: u32 = 0; bounce < bounces; bounce++) {\n\n        result = trace_tlas(world_ray);\n\n        if (!result.hit) {\n            //sky color\n            color = color * textureSampleLevel(skyTexture, skySampler, world_ray.direction, 0.0).xyz;\n            break;\n        }\n\n        //unpack color\n        color = color * result.color;\n\n        //Set up for next trace\n        world_ray.origin = world_ray.origin + result.t * world_ray.direction;\n        world_ray.direction = normalize(reflect(world_ray.direction, result.normal));\n    }\n\n    //Rays which reached terminal state and bounced indefinitely\n    if (result.hit) {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n\n    return color;\n}\n\nfn trace_tlas(ray: Ray) -> RenderState {\n\n    //Set up the Render State\n    var renderState: RenderState;\n    renderState.hit = false;\n    var nearestHit: f32 = 9999;\n\n    //Set up for BVH Traversal\n    var node: Node = tree.nodes[0];\n    var stack: array<Node, 20>;\n    var stackLocation: u32 = 0;\n\n    while (true) {\n\n        var primitiveCount: u32 = u32(node.primitiveCount);\n        var contents: u32 = u32(node.leftChild);\n\n        if (primitiveCount == 0) {\n            var child1: Node = tree.nodes[contents];\n            var child2: Node = tree.nodes[contents + 1];\n\n            var distance1: f32 = hit_aabb(ray, child1);\n            var distance2: f32 = hit_aabb(ray, child2);\n            if (distance1 > distance2) {\n                var tempDist: f32 = distance1;\n                distance1 = distance2;\n                distance2 = tempDist;\n\n                var tempChild: Node = child1;\n                child1 = child2;\n                child2 = tempChild;\n            }\n\n            if (distance1 > nearestHit) {\n                if (stackLocation == 0) {\n                    break;\n                }\n                else {\n                    stackLocation -= 1;\n                    node = stack[stackLocation];\n                }\n            }\n            else {\n                node = child1;\n                if (distance2 < nearestHit) {\n                    stack[stackLocation] = child2;\n                    stackLocation += 1;\n                }\n            }\n        }\n        else {\n            for (var i: u32 = 0; i < primitiveCount; i++) {\n        \n                var newRenderState: RenderState = trace_blas(\n                    ray, \n                    blas.descriptions[u32(blasLookup.primitiveIndices[i + contents])], \n                    nearestHit,\n                    renderState\n                );\n\n                if (newRenderState.hit) {\n                    nearestHit = newRenderState.t;\n                    renderState = newRenderState;\n                }\n            }\n\n            if (stackLocation == 0) {\n                break;\n            }\n            else {\n                stackLocation -= 1;\n                node = stack[stackLocation];\n            }\n        }\n    }\n\n    return renderState;\n}\n\nfn trace_blas(\n    ray: Ray, \n    description: blasDescription,\n    nearestHit: f32,\n    renderState: RenderState) -> RenderState {\n\n    var object_ray: Ray;\n    object_ray.origin = (description.inverseModel * vec4<f32>(ray.origin, 1.0)).xyz;\n    object_ray.direction = (description.inverseModel * vec4<f32>(ray.direction, 0.0)).xyz;\n\n    //Set up the Render State\n    var blasRenderState: RenderState;\n    blasRenderState.t = renderState.t;\n    blasRenderState.normal = renderState.normal;\n    blasRenderState.color = renderState.color;\n    blasRenderState.hit = false;\n\n    var blasNearestHit: f32 = nearestHit;\n\n    //Set up for BVH Traversal\n    var node: Node = tree.nodes[u32(description.rootNodeIndex.x)];\n    var stack: array<Node, 20>;\n    var stackLocation: u32 = 0;\n\n    while (true) {\n\n        var primitiveCount: u32 = u32(node.primitiveCount);\n        var contents: u32 = u32(node.leftChild);\n\n        if (primitiveCount == 0) {\n            var child1: Node = tree.nodes[contents];\n            var child2: Node = tree.nodes[contents + 1];\n\n            var distance1: f32 = hit_aabb(object_ray, child1);\n            var distance2: f32 = hit_aabb(object_ray, child2);\n            if (distance1 > distance2) {\n                var tempDist: f32 = distance1;\n                distance1 = distance2;\n                distance2 = tempDist;\n\n                var tempChild: Node = child1;\n                child1 = child2;\n                child2 = tempChild;\n            }\n\n            if (distance1 > blasNearestHit) {\n                if (stackLocation == 0) {\n                    break;\n                }\n                else {\n                    stackLocation -= 1;\n                    node = stack[stackLocation];\n                }\n            }\n            else {\n                node = child1;\n                if (distance2 < blasNearestHit) {\n                    stack[stackLocation] = child2;\n                    stackLocation += 1;\n                }\n            }\n        }\n        else {\n            for (var i: u32 = 0; i < primitiveCount; i++) {\n        \n                var newRenderState: RenderState = hit_triangle(\n                    object_ray, \n                    objects.triangles[u32(triangleLookup.primitiveIndices[i + contents])], \n                    0.001, blasNearestHit, blasRenderState\n                );\n\n                if (newRenderState.hit) {\n                    blasNearestHit = newRenderState.t;\n                    blasRenderState = newRenderState;\n                }\n            }\n\n            if (stackLocation == 0) {\n                break;\n            }\n            else {\n                stackLocation -= 1;\n                node = stack[stackLocation];\n            }\n        }\n    }\n\n    if (blasRenderState.hit) {\n        blasRenderState.normal = normalize(\n            (transpose(description.inverseModel) * vec4(blasRenderState.normal, 0.0)).xyz\n        );\n    }\n\n    return blasRenderState;\n}\n\nfn hit_sphere(ray: Ray, sphere: Sphere, tMin: f32, oldRenderState: RenderState) -> RenderState {\n    \n    let co: vec3<f32> = ray.origin - sphere.center;\n    let a: f32 = dot(ray.direction, ray.direction);\n    let b: f32 = 2.0 * dot(ray.direction, co);\n    let c: f32 = dot(co, co) - sphere.radius * sphere.radius;\n    let discriminant: f32 = b * b - 4.0 * a * c;\n\n    var renderState: RenderState;\n    renderState.color = oldRenderState.color;\n\n    if (discriminant > 0.0) {\n\n        let t: f32 = (-b - sqrt(discriminant)) / (2 * a);\n\n        if (t > tMin && t < oldRenderState.t) {\n            renderState.t = t;\n            renderState.color = sphere.color;\n            renderState.hit = true;\n            return renderState;\n        }\n    }\n\n    renderState.hit = false;\n    return renderState;\n    \n}\n\nfn hit_triangle(\n    ray: Ray, tri: Triangle, \n    tMin: f32, tMax:f32,\n    oldRenderState: RenderState) -> RenderState {\n\n    var renderState: RenderState;\n    renderState.color = oldRenderState.color;\n    renderState.hit = false;\n\n    //Direction vectors\n    let edge_ab: vec3<f32> = tri.corner_b - tri.corner_a;\n    let edge_ac: vec3<f32> = tri.corner_c - tri.corner_a;\n    //Normal of the triangle\n    var n: vec3<f32> = normalize(cross(edge_ab, edge_ac));\n    var ray_dot_tri: f32 = dot(ray.direction, n);\n    //backface reversal\n    if (ray_dot_tri > 0.0) {\n        //ray_dot_tri = ray_dot_tri * -1;\n        //n = n * -1;\n        return renderState;\n    }\n    //early exit, ray parallel with triangle surface\n    if (abs(ray_dot_tri) < 0.00001) {\n        return renderState;\n    }\n\n    var system_matrix: mat3x3<f32> = mat3x3<f32>(\n        ray.direction,\n        tri.corner_a - tri.corner_b,\n        tri.corner_a - tri.corner_c\n    );\n    let denominator: f32 = determinant(system_matrix);\n    if (abs(denominator) < 0.00001) {\n        return renderState;\n    }\n\n    system_matrix = mat3x3<f32>(\n        ray.direction,\n        tri.corner_a - ray.origin,\n        tri.corner_a - tri.corner_c\n    );\n    let u: f32 = determinant(system_matrix) / denominator;\n    \n    if (u < 0.0 || u > 1.0) {\n        return renderState;\n    }\n\n    system_matrix = mat3x3<f32>(\n        ray.direction,\n        tri.corner_a - tri.corner_b,\n        tri.corner_a - ray.origin,\n    );\n    let v: f32 = determinant(system_matrix) / denominator;\n    if (v < 0.0 || u + v > 1.0) {\n        return renderState;\n    }\n\n    system_matrix = mat3x3<f32>(\n        tri.corner_a - ray.origin,\n        tri.corner_a - tri.corner_b,\n        tri.corner_a - tri.corner_c\n    );\n    let t: f32 = determinant(system_matrix) / denominator;\n\n    if (t > tMin && t < tMax) {\n        renderState.normal = (1.0 - u - v) * tri.normal_a + u * tri.normal_b + v * tri.normal_c;\n        renderState.color = tri.color;\n        renderState.t = t;\n        renderState.hit = true;\n        return renderState;\n    }\n\n    return renderState;\n}\n\nfn hit_aabb(ray: Ray, node: Node) -> f32 {\n\n    var inverseDir: vec3<f32> = vec3(1.0) / ray.direction;\n    var t1: vec3<f32> = (node.minCorner - ray.origin) * inverseDir;\n    var t2: vec3<f32> = (node.maxCorner - ray.origin) * inverseDir;\n    var tMin: vec3<f32> = min(t1, t2);\n    var tMax: vec3<f32> = max(t1, t2);\n\n    var t_min: f32 = max(max(tMin.x, tMin.y), tMin.z);\n    var t_max: f32 = min(min(tMax.x, tMax.y), tMax.z);\n\n    if (t_min > t_max || t_max < 0) {\n        return 99999;\n    }\n    else {\n        return t_min;\n    }\n}",["main"]),await this.screen_pipeline.build("@group(0) @binding(0) var screen_sampler : sampler;\r\n@group(0) @binding(1) var color_buffer : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n    @builtin(position) Position : vec4<f32>,\r\n    @location(0) TexCoord : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vert_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n\r\n    var positions = array<vec2<f32>, 6>(\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>( 1.0, -1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>(-1.0,  1.0)\r\n    );\r\n\r\n    var texCoords = array<vec2<f32>, 6>(\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(1.0, 1.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(0.0, 0.0)\r\n    );\r\n\r\n    var output : VertexOutput;\r\n    output.Position = vec4<f32>(positions[VertexIndex], 0.0, 1.0);\r\n    output.TexCoord = texCoords[VertexIndex];\r\n    return output;\r\n}\r\n\r\n@fragment\r\nfn frag_main(@location(0) TexCoord : vec2<f32>) -> @location(0) vec4<f32> {\r\n  return textureSample(color_buffer, screen_sampler, TexCoord);\r\n}",["vert_main","frag_main"])}prepareScene(){this.sceneParameters.blit(this.scene.camera.data,0),this.sceneParameters.upload();for(let e=0;e<this.scene.blasDescriptions.length;e++)this.scene.blasDescriptions[e].flatten(),this.blasDescriptionBuffer.blit(this.scene.blasDescriptions[e].data,20*e);this.blasDescriptionBuffer.upload(),this.scene.flattenObjects(),this.blasIndexBuffer.blit(this.scene.blasIndexData,0),this.blasIndexBuffer.upload();for(let e=0;e<this.scene.nodesUsed;e++)this.scene.nodes[e].flatten(),this.nodeBuffer.blit(this.scene.nodes[e].data,8*e);if(this.device.queue.writeBuffer(this.nodeBuffer.deviceMemory,0,this.nodeBuffer.hostMemory,0,8*this.scene.nodesUsed),!this.loaded){this.loaded=!0;for(let e=0;e<this.scene.triangles.length;e++)this.scene.triangles[e].flatten(),this.triangleBuffer.blit(this.scene.triangles[e].data,28*e);this.triangleBuffer.upload();for(let e=0;e<this.scene.statue_mesh.nodesUsed;e++){let t=this.scene.tlasNodesMax+e;this.scene.nodes[t].flatten(),this.nodeBuffer.blit(this.scene.nodes[t].data,8*t)}this.nodeBuffer.upload(),this.triangleIndexBuffer.blit(this.scene.triangleIndexData,0),this.triangleIndexBuffer.upload()}}}},127:(e,t,n)=>{n.d(t,{Z:()=>g});var i="undefined"!=typeof Float32Array?Float32Array:Array;function r(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function s(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function a(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e}function o(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e}function d(e,t,n){var i=t[0],r=t[1],s=t[2],a=n[0],o=n[1],d=n[2];return e[0]=r*d-s*o,e[1]=s*a-i*d,e[2]=i*o-r*a,e}function c(e){return e*Math.PI/180}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)}),r();class h{constructor(e,t){this.position=new Float32Array(e),this.theta=0,this.phi=0,this.data=new Float32Array(16),this.data[11]=t,this.recalculate_vectors()}recalculate_vectors(){this.forwards=new Float32Array([Math.cos(c(this.theta))*Math.cos(c(this.phi)),Math.sin(c(this.theta))*Math.cos(c(this.phi)),Math.sin(c(this.theta))]),this.right=new Float32Array([0,0,0]),d(this.right,this.forwards,[0,0,1]),this.up=new Float32Array([0,0,0]),d(this.up,this.right,this.forwards),this.data[0]=this.position[0],this.data[1]=this.position[1],this.data[2]=this.position[2],this.data[4]=this.forwards[0],this.data[5]=this.forwards[1],this.data[6]=this.forwards[2],this.data[8]=this.right[0],this.data[9]=this.right[1],this.data[10]=this.right[2],this.data[12]=this.up[0],this.data[13]=this.up[1],this.data[14]=this.up[2]}}class l{constructor(){this.data=new Float32Array(8)}flatten(){this.data[0]=this.minCorner[0],this.data[1]=this.minCorner[1],this.data[2]=this.minCorner[2],this.data[3]=this.leftChild,this.data[4]=this.maxCorner[0],this.data[5]=this.maxCorner[1],this.data[6]=this.maxCorner[2],this.data[7]=this.primitiveCount}}class u{constructor(){this.corners=[],this.normals=[],this.data=new Float32Array(28)}build_from_center_and_offsets(e,t,n){this.centroid=[0,0,0];const i=[.33333,.33333,.33333];t.forEach((t=>{var n=[e[0],e[1],e[2]];this.corners.push([n[0]+t[0],n[1]+t[1],n[2]+t[2]]);var r,s,a,o=[n[0],n[1],n[2]];(function(e,t,n){e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2]})(o,o,i),r=this.centroid,s=this.centroid,a=o,r[0]=s[0]+a[0],r[1]=s[1]+a[1],r[2]=s[2]+a[2]}));var r=[0,0,0];d(r,[this.corners[1][0]-this.corners[0][0],this.corners[1][1]-this.corners[0][1],this.corners[1][2]-this.corners[0][2]],[this.corners[1][0]-this.corners[0][0],this.corners[1][1]-this.corners[0][1],this.corners[1][2]-this.corners[0][2]]),this.normals.push(r),this.normals.push(r),this.normals.push(r),this.color=n;for(var s=0;s<3;s++)this.data[8*s]=this.corners[s][0],this.data[8*s+1]=this.corners[s][1],this.data[8*s+2]=this.corners[s][2],this.data[8*s+4]=this.normals[s][0],this.data[8*s+5]=this.normals[s][1],this.data[8*s+6]=this.normals[s][2];for(var a=0;a<3;a++)this.data[24+a]=this.color[a]}flatten(){for(var e=0;e<3;e++)this.data[8*e]=this.corners[e][0],this.data[8*e+1]=this.corners[e][1],this.data[8*e+2]=this.corners[e][2],this.data[8*e+4]=this.normals[e][0],this.data[8*e+5]=this.normals[e][1],this.data[8*e+6]=this.normals[e][2];for(var t=0;t<3;t++)this.data[24+t]=this.color[t]}make_centroid(){this.centroid=[(this.corners[0][0]+this.corners[1][0]+this.corners[2][0])/3,(this.corners[0][1]+this.corners[1][1]+this.corners[2][1])/3,(this.corners[0][2]+this.corners[1][2]+this.corners[2][2])/3]}}class f{constructor(){this.v=[],this.vt=[],this.vn=[],this.triangles=[],this.minCorner=[999999,999999,999999],this.maxCorner=[-999999,-999999,-999999]}async initialize(e,t){this.color=e,await this.readFile(t),this.v=[],this.vt=[],this.vn=[],this.buildBVH()}async readFile(e){var t=[];const n=await fetch(e),i=await n.blob();(await i.text()).split("\n").forEach((e=>{"v"==e[0]&&" "==e[1]?this.read_vertex_data(e):"v"==e[0]&&"t"==e[1]?this.read_texcoord_data(e):"v"==e[0]&&"n"==e[1]?this.read_normal_data(e):"f"==e[0]&&this.read_face_data(e,t)}))}read_vertex_data(e){const t=e.split(" "),n=[Number(t[1]).valueOf(),Number(t[2]).valueOf(),Number(t[3]).valueOf()];this.v.push(n),a(this.minCorner,this.minCorner,n),o(this.maxCorner,this.maxCorner,n)}read_texcoord_data(e){const t=e.split(" "),n=[Number(t[1]).valueOf(),Number(t[2]).valueOf()];this.vt.push(n)}read_normal_data(e){const t=e.split(" "),n=[Number(t[1]).valueOf(),Number(t[2]).valueOf(),Number(t[3]).valueOf()];this.vn.push(n)}read_face_data(e,t){const n=(e=e.replace("\n","")).split(" "),i=n.length-3;for(var r=0;r<i;r++){var s=new u;this.read_corner(n[1],s),this.read_corner(n[2+r],s),this.read_corner(n[3+r],s),s.color=this.color,s.make_centroid(),this.triangles.push(s)}}read_corner(e,t){const n=e.split("/"),i=this.v[Number(n[0]).valueOf()-1],r=(this.vt[Number(n[1]).valueOf()-1],this.vn[Number(n[2]).valueOf()-1]);t.corners.push(i),t.normals.push(r)}buildBVH(){this.triangleIndices=new Array(this.triangles.length);for(var e=0;e<this.triangles.length;e+=1)this.triangleIndices[e]=e;for(this.nodes=new Array(2*this.triangles.length-1),e=0;e<2*this.triangles.length-1;e+=1)this.nodes[e]=new l;var t=this.nodes[0];t.leftChild=0,t.primitiveCount=this.triangles.length,this.nodesUsed=1,this.updateBounds(0),this.subdivide(0)}updateBounds(e){var t=this.nodes[e];t.minCorner=[999999,999999,999999],t.maxCorner=[-999999,-999999,-999999];for(var n=0;n<t.primitiveCount;n+=1)this.triangles[this.triangleIndices[t.leftChild+n]].corners.forEach((e=>{a(t.minCorner,t.minCorner,e),o(t.maxCorner,t.maxCorner,e)}))}subdivide(e){var t=this.nodes[e];if(t.primitiveCount<2)return;var n=[0,0,0];s(n,t.maxCorner,t.minCorner);var i=0;n[1]>n[i]&&(i=1),n[2]>n[i]&&(i=2);const r=t.minCorner[i]+n[i]/2;for(var a=t.leftChild,o=a+t.primitiveCount-1;a<=o;)if(this.triangles[this.triangleIndices[a]].centroid[i]<r)a+=1;else{var d=this.triangleIndices[a];this.triangleIndices[a]=this.triangleIndices[o],this.triangleIndices[o]=d,o-=1}var c=a-t.leftChild;if(0==c||c==t.primitiveCount)return;const h=this.nodesUsed;this.nodesUsed+=1;const l=this.nodesUsed;this.nodesUsed+=1,this.nodes[h].leftChild=t.leftChild,this.nodes[h].primitiveCount=c,this.nodes[l].leftChild=a,this.nodes[l].primitiveCount=t.primitiveCount-c,t.leftChild=h,t.primitiveCount=0,this.updateBounds(h),this.updateBounds(l),this.subdivide(h),this.subdivide(l)}}function m(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}class v{constructor(e,t){this.position=e,this.eulers=t,this.calculate_transform()}update(e){this.eulers[2]+=.5*e,this.eulers[2]>360&&(this.eulers[2]-=360),this.calculate_transform()}calculate_transform(){var e,t,n,i,r,s,a,o,d,h,l,u,f,v,p,g,b,_;this.model=m(),e=this.model,t=this.model,g=(n=this.position)[0],b=n[1],_=n[2],t===e?(e[12]=t[0]*g+t[4]*b+t[8]*_+t[12],e[13]=t[1]*g+t[5]*b+t[9]*_+t[13],e[14]=t[2]*g+t[6]*b+t[10]*_+t[14],e[15]=t[3]*g+t[7]*b+t[11]*_+t[15]):(i=t[0],r=t[1],s=t[2],a=t[3],o=t[4],d=t[5],h=t[6],l=t[7],u=t[8],f=t[9],v=t[10],p=t[11],e[0]=i,e[1]=r,e[2]=s,e[3]=a,e[4]=o,e[5]=d,e[6]=h,e[7]=l,e[8]=u,e[9]=f,e[10]=v,e[11]=p,e[12]=i*g+o*b+u*_+t[12],e[13]=r*g+d*b+f*_+t[13],e[14]=s*g+h*b+v*_+t[14],e[15]=a*g+l*b+p*_+t[15]),function(e,t,n){var i=Math.sin(n),r=Math.cos(n),s=t[0],a=t[1],o=t[2],d=t[3],c=t[4],h=t[5],l=t[6],u=t[7];t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*r+c*i,e[1]=a*r+h*i,e[2]=o*r+l*i,e[3]=d*r+u*i,e[4]=c*r-s*i,e[5]=h*r-a*i,e[6]=l*r-o*i,e[7]=u*r-d*i}(this.model,this.model,c(this.eulers[2])),function(e,t,n){var i=Math.sin(n),r=Math.cos(n),s=t[4],a=t[5],o=t[6],d=t[7],c=t[8],h=t[9],l=t[10],u=t[11];t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=s*r+c*i,e[5]=a*r+h*i,e[6]=o*r+l*i,e[7]=d*r+u*i,e[8]=c*r-s*i,e[9]=h*r-a*i,e[10]=l*r-o*i,e[11]=u*r-d*i}(this.model,this.model,c(this.eulers[0]))}}class p{constructor(e,t,n){this.inverseModel=m(),this.minCorner=[999999,999999,999999],this.maxCorner=[-999999,-999999,-999999];var i=r();const s=[[e[0],e[1],e[2]],[e[0],e[1],t[2]],[e[0],t[1],e[2]],[e[0],t[1],t[2]],[t[0],e[1],e[2]],[t[0],e[1],t[2]],[t[0],t[1],e[2]],[t[0],t[1],t[2]]];for(let e=0;e<8;e++)d=i,h=n,void 0,void 0,void 0,v=void 0,l=(c=s[e])[0],u=c[1],f=c[2],v=(v=h[3]*l+h[7]*u+h[11]*f+h[15])||1,d[0]=(h[0]*l+h[4]*u+h[8]*f+h[12])/v,d[1]=(h[1]*l+h[5]*u+h[9]*f+h[13])/v,d[2]=(h[2]*l+h[6]*u+h[10]*f+h[14])/v,a(this.minCorner,this.minCorner,i),o(this.maxCorner,this.maxCorner,i);var d,c,h,l,u,f,v;this.center=[(this.minCorner[0]+this.maxCorner[0])/2,(this.minCorner[1]+this.maxCorner[1])/2,(this.minCorner[2]+this.maxCorner[2])/2],function(e,t){var n=t[0],i=t[1],r=t[2],s=t[3],a=t[4],o=t[5],d=t[6],c=t[7],h=t[8],l=t[9],u=t[10],f=t[11],m=t[12],v=t[13],p=t[14],g=t[15],b=n*o-i*a,_=n*d-r*a,y=n*c-s*a,x=i*d-r*o,C=i*c-s*o,S=r*c-s*d,w=h*v-l*m,I=h*p-u*m,B=h*g-f*m,M=l*p-u*v,k=l*g-f*v,R=u*g-f*p,U=b*R-_*k+y*M+x*B-C*I+S*w;U&&(U=1/U,e[0]=(o*R-d*k+c*M)*U,e[1]=(r*k-i*R-s*M)*U,e[2]=(v*S-p*C+g*x)*U,e[3]=(u*C-l*S-f*x)*U,e[4]=(d*B-a*R-c*I)*U,e[5]=(n*R-r*B+s*I)*U,e[6]=(p*y-m*S-g*_)*U,e[7]=(h*S-u*y+f*_)*U,e[8]=(a*k-o*B+c*w)*U,e[9]=(i*B-n*k-s*w)*U,e[10]=(m*C-v*y+g*b)*U,e[11]=(l*y-h*C-f*b)*U,e[12]=(o*I-a*M-d*w)*U,e[13]=(n*M-i*I+r*w)*U,e[14]=(v*_-m*x-p*b)*U,e[15]=(h*x-l*_+u*b)*U)}(this.inverseModel,n),this.data=new Float32Array(20);for(let e=0;e<16;e++)this.data[e]=this.inverseModel.at(e);this.data[16]=this.rootNodeIndex,this.data[17]=this.rootNodeIndex,this.data[18]=this.rootNodeIndex,this.data[19]=this.rootNodeIndex}flatten(){for(let e=0;e<16;e++)this.data[e]=this.inverseModel.at(e);this.data[16]=this.rootNodeIndex,this.data[17]=this.rootNodeIndex,this.data[18]=this.rootNodeIndex,this.data[19]=this.rootNodeIndex}}class g{constructor(){this.nodesUsed=0,this.blas_consumed=!1,this.debugMode=!1,this.statue_mesh=new f,this.statues=new Array(9);var e=0;for(let t=-2;t<=2;t++)for(let n=-2;n<=2;n++)for(let i=-2;i<=2;i++)this.statues[e]=new v([2*n,2*t,4*i],[180,0,90]),e+=1;this.camera=new h([-6,0,-1],4)}async make_scene(){if(await this.statue_mesh.initialize([1,1,1],"dist/models/statue.obj"),this.debugMode){console.log("Bottom Level Acceleration Structure:");for(let e=0;e<this.statue_mesh.nodesUsed;e++){let t=this.statue_mesh.nodes[e];0==t.primitiveCount?(console.log("Internal Node:"),console.log("\tIndex: %d",e),console.log("\tleft child: %d, right child: %d",t.leftChild,t.leftChild+1)):(console.log("External Node:"),console.log("\tIndex: %d",e),console.log("\tfirst primitive index: %d, primitive count: %d",t.leftChild,t.primitiveCount)),console.log("\t Extent: (%f, %f, %f) -> (%f, %f, %f)",t.minCorner[0],t.minCorner[1],t.minCorner[2],t.maxCorner[0],t.maxCorner[1],t.maxCorner[2])}}this.triangles=[],this.statue_mesh.triangles.forEach((e=>{this.triangles.push(e)})),this.triangleIndices=[],this.triangleIndexData=new Float32Array(this.triangles.length),this.statue_mesh.triangleIndices.forEach((e=>{this.triangleIndices.push(e)})),this.tlasNodesMax=2*this.statues.length-1;const e=this.statue_mesh.nodesUsed;this.nodes=new Array(this.tlasNodesMax+e);for(var t=0;t<this.tlasNodesMax+e;t+=1)this.nodes[t]=new l,this.nodes[t].leftChild=0,this.nodes[t].primitiveCount=0,this.nodes[t].minCorner=[0,0,0],this.nodes[t].maxCorner=[0,0,0];this.buildBVH(),this.finalizeBVH(),this.blas_consumed=!0,this.flattenTriangles()}flattenTriangles(){for(let e=0;e<this.triangles.length;e++)this.triangleIndexData[e]=this.triangleIndices[e]}flattenObjects(){for(let e=0;e<this.blasIndices.length;e++)this.blasIndexData[e]=this.blasIndices[e]}update(e){this.statues.forEach((t=>{t.update(e/16.667)})),this.buildBVH()}buildBVH(){const e=this.statue_mesh.nodesUsed;this.debugMode&&console.log("TLAS needs %d nodes, BLAS needs %d nodes, total: %d nodes",this.tlasNodesMax,e,this.tlasNodesMax+e),this.nodesUsed=0,this.blasDescriptions=new Array(this.statues.length),this.blasIndices=new Array(this.statues.length),this.blasIndexData=new Float32Array(this.statues.length);for(var t=0;t<this.statues.length;t++){var n=new p(this.statue_mesh.minCorner,this.statue_mesh.maxCorner,this.statues[t].model);n.rootNodeIndex=this.tlasNodesMax,this.blasDescriptions[t]=n,this.blasIndices[t]=t}if(this.debugMode){console.log("BLAS descriptions:");for(let e=0;e<this.blasDescriptions.length;e++){let t=this.blasDescriptions[e];console.log("Index: %d",e),console.log("\t Extent: (%f, %f, %f) -> (%f, %f, %f)",t.minCorner[0],t.minCorner[1],t.minCorner[2],t.maxCorner[0],t.maxCorner[1],t.maxCorner[2]),console.log("\t Root node index: %d",t.rootNodeIndex)}}for(t=0;t<this.tlasNodesMax;t+=1)this.nodes[t].leftChild=0,this.nodes[t].primitiveCount=0,this.nodes[t].minCorner=[0,0,0],this.nodes[t].maxCorner=[0,0,0];var i=this.nodes[0];i.leftChild=0,i.primitiveCount=this.blasDescriptions.length,this.nodesUsed+=1,this.updateBounds(0),this.subdivide(0)}updateBounds(e){var t=this.nodes[e];t.minCorner=[999999,999999,999999],t.maxCorner=[-999999,-999999,-999999];for(var n=0;n<t.primitiveCount;n+=1){const e=this.blasDescriptions[this.blasIndices[t.leftChild+n]];a(t.minCorner,t.minCorner,e.minCorner),o(t.maxCorner,t.maxCorner,e.maxCorner)}}subdivide(e){var t=this.nodes[e];if(t.primitiveCount<2)return;var n=[0,0,0];s(n,t.maxCorner,t.minCorner);var i=0;n[1]>n[i]&&(i=1),n[2]>n[i]&&(i=2);const r=t.minCorner[i]+n[i]/2;for(var a=t.leftChild,o=a+t.primitiveCount-1;a<=o;)if(this.blasDescriptions[this.blasIndices[a]].center[i]<r)a+=1;else{var d=this.blasIndices[a];this.blasIndices[a]=this.blasIndices[o],this.blasIndices[o]=d,o-=1}var c=a-t.leftChild;if(0==c||c==t.primitiveCount)return;const h=this.nodesUsed;this.nodesUsed+=1;const l=this.nodesUsed;this.nodesUsed+=1,this.nodes[h].leftChild=t.leftChild,this.nodes[h].primitiveCount=c,this.nodes[l].leftChild=a,this.nodes[l].primitiveCount=t.primitiveCount-c,t.leftChild=h,t.primitiveCount=0,this.updateBounds(h),this.updateBounds(l),this.subdivide(h),this.subdivide(l)}finalizeBVH(){if(this.debugMode){console.log("BLAS mappings:");for(let e=0;e<this.blasIndices.length;e++)console.log("Index: %d maps to %d",e,this.blasIndices[e]);console.log("Top Level Acceleration Structure:");for(let e=0;e<this.nodesUsed;e++){let t=this.nodes[e];0==t.primitiveCount?(console.log("Internal Node:"),console.log("\tIndex: %d",e),console.log("\tleft child: %d, right child: %d",t.leftChild,t.leftChild+1)):(console.log("External Node:"),console.log("\tIndex: %d",e),console.log("\tfirst blas index: %d, blas count: %d",t.leftChild,t.primitiveCount)),console.log("\t Extent: (%f, %f, %f) -> (%f, %f, %f)",t.minCorner[0],t.minCorner[1],t.minCorner[2],t.maxCorner[0],t.maxCorner[1],t.maxCorner[2])}}for(var e=0;e<this.statue_mesh.nodesUsed;e++){var t=this.statue_mesh.nodes[e];0==t.primitiveCount&&(t.leftChild+=this.tlasNodesMax),this.nodes[this.tlasNodesMax+e]=t}if(this.debugMode){console.log("Final Nodes:");for(let e=0;e<this.nodes.length;e++){let t=this.nodes[e];0==t.primitiveCount?(console.log("Internal Node:"),console.log("\tIndex: %d",e),console.log("\tleft child: %d, right child: %d",t.leftChild,t.leftChild+1)):(console.log("External Node:"),console.log("\tIndex: %d",e),console.log("\tfirst primitive index: %d, primitive count: %d",t.leftChild,t.primitiveCount)),console.log("\t Extent: (%f, %f, %f) -> (%f, %f, %f)",t.minCorner[0],t.minCorner[1],t.minCorner[2],t.maxCorner[0],t.maxCorner[1],t.maxCorner[2])}}}}}},s={};function a(e){var t=s[e];if(void 0!==t)return t.exports;var n=s[e]={exports:{}};return r[e](n,n.exports,a),n.exports}e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",t="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",n="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",i=e=>{e&&e.d<1&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},a.a=(r,s,a)=>{var o;a&&((o=[]).d=-1);var d,c,h,l=new Set,u=r.exports,f=new Promise(((e,t)=>{h=t,c=e}));f[t]=u,f[e]=e=>(o&&e(o),l.forEach(e),f.catch((e=>{}))),r.exports=f,s((r=>{var s;d=(r=>r.map((r=>{if(null!==r&&"object"==typeof r){if(r[e])return r;if(r.then){var s=[];s.d=0,r.then((e=>{a[t]=e,i(s)}),(e=>{a[n]=e,i(s)}));var a={};return a[e]=e=>e(s),a}}var o={};return o[e]=e=>{},o[t]=r,o})))(r);var a=()=>d.map((e=>{if(e[n])throw e[n];return e[t]})),c=new Promise((t=>{(s=()=>t(a)).r=0;var n=e=>e!==o&&!l.has(e)&&(l.add(e),e&&!e.d&&(s.r++,e.push(s)));d.map((t=>t[e](n)))}));return s.r?c:a()}),(e=>(e?h(f[n]=e):c(u),i(o)))),o&&o.d<0&&(o.d=0)},a.d=(e,t)=>{for(var n in t)a.o(t,n)&&!a.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),a(927)})();