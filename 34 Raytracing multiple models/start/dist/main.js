(()=>{"use strict";var e,t,n,r,i={823:(e,t,n)=>{n.d(t,{tb:()=>r});var r="undefined"!=typeof Float32Array?Float32Array:Array;Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)})},684:(e,t,n)=>{n.d(t,{Qr:()=>o,Tl:()=>s,eL:()=>a,vt:()=>i});var r=n(823);function i(){var e=new r.tb(16);return r.tb!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function s(e,t,n){var r,i,s,a,o,h,c,d,l,u,f,m,_=n[0],p=n[1],v=n[2];return t===e?(e[12]=t[0]*_+t[4]*p+t[8]*v+t[12],e[13]=t[1]*_+t[5]*p+t[9]*v+t[13],e[14]=t[2]*_+t[6]*p+t[10]*v+t[14],e[15]=t[3]*_+t[7]*p+t[11]*v+t[15]):(r=t[0],i=t[1],s=t[2],a=t[3],o=t[4],h=t[5],c=t[6],d=t[7],l=t[8],u=t[9],f=t[10],m=t[11],e[0]=r,e[1]=i,e[2]=s,e[3]=a,e[4]=o,e[5]=h,e[6]=c,e[7]=d,e[8]=l,e[9]=u,e[10]=f,e[11]=m,e[12]=r*_+o*p+l*v+t[12],e[13]=i*_+h*p+u*v+t[13],e[14]=s*_+c*p+f*v+t[14],e[15]=a*_+d*p+m*v+t[15]),e}function a(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[4],a=t[5],o=t[6],h=t[7],c=t[8],d=t[9],l=t[10],u=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=s*i+c*r,e[5]=a*i+d*r,e[6]=o*i+l*r,e[7]=h*i+u*r,e[8]=c*i-s*r,e[9]=d*i-a*r,e[10]=l*i-o*r,e[11]=u*i-h*r,e}function o(e,t,n){var r=Math.sin(n),i=Math.cos(n),s=t[0],a=t[1],o=t[2],h=t[3],c=t[4],d=t[5],l=t[6],u=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=s*i+c*r,e[1]=a*i+d*r,e[2]=o*i+l*r,e[3]=h*i+u*r,e[4]=c*i-s*r,e[5]=d*i-a*r,e[6]=l*i-o*r,e[7]=u*i-h*r,e}},329:(e,t,n)=>{n.d(t,{$A:()=>u,Om:()=>l,Re:()=>a,T9:()=>c,WQ:()=>s,Z0:()=>f,hs:()=>d,jk:()=>h,lw:()=>o,vt:()=>i});var r=n(823);function i(){var e=new r.tb(3);return r.tb!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function s(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function a(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function o(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}function h(e,t,n){return e[0]=Math.min(t[0],n[0]),e[1]=Math.min(t[1],n[1]),e[2]=Math.min(t[2],n[2]),e}function c(e,t,n){return e[0]=Math.max(t[0],n[0]),e[1]=Math.max(t[1],n[1]),e[2]=Math.max(t[2],n[2]),e}function d(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function l(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function u(e,t,n){var r=t[0],i=t[1],s=t[2],a=n[0],o=n[1],h=n[2];return e[0]=i*h-s*o,e[1]=s*a-r*h,e[2]=r*o-i*a,e}function f(e,t,n){var r=t[0],i=t[1],s=t[2],a=n[3]*r+n[7]*i+n[11]*s+n[15];return a=a||1,e[0]=(n[0]*r+n[4]*i+n[8]*s+n[12])/a,e[1]=(n[1]*r+n[5]*i+n[9]*s+n[13])/a,e[2]=(n[2]*r+n[6]*i+n[10]*s+n[14])/a,e}i()},927:(e,t,n)=>{n.a(e,(async(e,t)=>{try{var r=n(195),i=n(461);const e=document.getElementById("gfx-main"),s=(document.getElementById("sphere-count"),new r.Z),a=new i.A(e,s);await a.Initialize(),t()}catch(e){t(e)}}),1)},461:(e,t,n)=>{n.d(t,{A:()=>m});class r{async initialize(e,t){for(var n=new Array(6),r=0;r<6;r++){const e=await fetch(t[r]),i=await e.blob();n[r]=await createImageBitmap(i)}await this.loadImageBitmaps(e,n),this.view=this.texture.createView({format:"rgba8unorm",dimension:"cube",aspect:"all",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:0,arrayLayerCount:6}),this.sampler=e.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"nearest",mipmapFilter:"nearest",maxAnisotropy:1})}async loadImageBitmaps(e,t){const n={dimension:"2d",size:{width:t[0].width,height:t[0].height,depthOrArrayLayers:6},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT};this.texture=e.createTexture(n);for(var r=0;r<6;r++)e.queue.copyExternalImageToTexture({source:t[r]},{texture:this.texture,origin:[0,0,r]},[t[r].width,t[r].height])}}class i{constructor(e,t){this.device=e,this.visibility=t,this.entries=new Array,this.binding=0}addImage2D(){this.visibility==GPUShaderStage.COMPUTE?(this.entries.push({binding:this.binding,visibility:this.visibility,storageTexture:{access:"write-only",format:"rgba8unorm",viewDimension:"2d"}}),this.binding+=1):(this.entries.push({binding:this.binding,visibility:this.visibility,sampler:{}}),this.binding+=1,this.entries.push({binding:this.binding,visibility:GPUShaderStage.FRAGMENT,texture:{}}),this.binding+=1)}addBuffer(e){this.entries.push({binding:this.binding,visibility:this.visibility,buffer:{type:e,hasDynamicOffset:!1}}),this.binding+=1}addImageCube(){this.entries.push({binding:this.binding,visibility:this.visibility,texture:{viewDimension:"cube"}}),this.binding+=1,this.entries.push({binding:this.binding,visibility:this.visibility,sampler:{}}),this.binding+=1}async makeBindGroupLayout(){this.bind_group_layout=this.device.createBindGroupLayout({entries:this.entries})}async build(e,t){const n=this.device.createPipelineLayout({bindGroupLayouts:[this.bind_group_layout]});this.visibility==GPUShaderStage.COMPUTE?this.pipeline=this.device.createComputePipeline({layout:n,compute:{module:this.device.createShaderModule({code:e}),entryPoint:t[0]}}):this.pipeline=this.device.createRenderPipeline({layout:n,vertex:{module:this.device.createShaderModule({code:e}),entryPoint:t[0]},fragment:{module:this.device.createShaderModule({code:e}),entryPoint:t[1],targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}})}}class s{constructor(e,t,n){this.offset=e,this.size=t,this.payload=n}}class a{constructor(e){this.device=e,this.usage=0,this.size=0,this.coarse_partitions=[],this.hostMemories=[],this.fine_partitions=[]}add_coarse_partition(e,t){let n=this.size;this.size+=e,this.usage|=t;let r=this.device.limits;if(console.log("Add Coarse Partition"),t&GPUBufferUsage.STORAGE){let e=r.minStorageBufferOffsetAlignment,t=e-(n&e-1)&e-1;this.size+=t,n+=t,console.log("Required Alignment: %d, Padding: %d",e,t)}if(t&GPUBufferUsage.UNIFORM){let e=r.minUniformBufferOffsetAlignment,t=e-(n&e-1)&e-1;this.size+=t,n+=t,console.log("Required Alignment: %d, Padding: %d",e,t)}return this.coarse_partitions.push(new s(n,e,[])),this.hostMemories.push(new Float32Array(e/4)),this.fine_partitions.push([]),this.coarse_partitions.length-1}async Initialize(){const e={size:this.size,usage:this.usage};this.deviceMemory=this.device.createBuffer(e)}add_fine_partition(e,t,n){let r=this.fine_partitions[e],i=r.length,a=0;if(i>0){let e=r[i-1];a=e.offset+e.size}return r.push(new s(a,t,n)),i}blit_to_coarse_partition(e,t,n){this.hostMemories[e].set(t,n)}upload_coarse_partition(e){let t=this.hostMemories[e],n=t.length;this.device.queue.writeBuffer(this.deviceMemory,0,t,0,n)}get_fine_partition(e,t){return this.fine_partitions[e][t]}get_coarse_partition(e){return this.coarse_partitions[e]}blit_to_fine_partition(e,t,n){let r=this.hostMemories[e],i=this.fine_partitions[e][t].offset;r.set(n,i)}upload_fine_partition(e,t){let n=this.coarse_partitions[e],r=this.fine_partitions[e][t],i=n.offset+4*r.offset,s=r.offset,a=r.size,o=this.hostMemories[e];this.device.queue.writeBuffer(this.deviceMemory,i,o,s,a)}}var o=n(329);class h{constructor(){this.minCorner=[1e30,1e30,1e30],this.maxCorner=[-1e30,-1e30,-1e30],this.data=new Float32Array(8)}flatten(){this.data[0]=this.minCorner[0],this.data[1]=this.minCorner[1],this.data[2]=this.minCorner[2],this.data[3]=this.leftChild,this.data[4]=this.maxCorner[0],this.data[5]=this.maxCorner[1],this.data[6]=this.maxCorner[2],this.data[7]=this.primitiveCount}}class c{constructor(){this.corners=[],this.normals=[],this.data=new Float32Array(28)}build_from_center_and_offsets(e,t,n){this.centroid=[0,0,0];const r=[.33333,.33333,.33333];t.forEach((t=>{var n=[e[0],e[1],e[2]];this.corners.push([n[0]+t[0],n[1]+t[1],n[2]+t[2]]);var i=[n[0],n[1],n[2]];o.lw(i,i,r),o.WQ(this.centroid,this.centroid,i)}));const i=[this.corners[1][0]-this.corners[0][0],this.corners[1][1]-this.corners[0][1],this.corners[1][2]-this.corners[0][2]],s=[this.corners[1][0]-this.corners[0][0],this.corners[1][1]-this.corners[0][1],this.corners[1][2]-this.corners[0][2]];var a=[0,0,0];o.$A(a,i,s),this.normals.push(a),this.normals.push(a),this.normals.push(a),this.color=n;for(var h=0;h<3;h++)this.data[8*h]=this.corners[h][0],this.data[8*h+1]=this.corners[h][1],this.data[8*h+2]=this.corners[h][2],this.data[8*h+4]=this.normals[h][0],this.data[8*h+5]=this.normals[h][1],this.data[8*h+6]=this.normals[h][2];for(var c=0;c<3;c++)this.data[24+c]=this.color[c]}flatten(){for(var e=0;e<3;e++)this.data[8*e]=this.corners[e][0],this.data[8*e+1]=this.corners[e][1],this.data[8*e+2]=this.corners[e][2],this.data[8*e+4]=this.normals[e][0],this.data[8*e+5]=this.normals[e][1],this.data[8*e+6]=this.normals[e][2];for(var t=0;t<3;t++)this.data[24+t]=this.color[t]}make_centroid(){this.centroid=[(this.corners[0][0]+this.corners[1][0]+this.corners[2][0])/3,(this.corners[0][1]+this.corners[1][1]+this.corners[2][1])/3,(this.corners[0][2]+this.corners[1][2]+this.corners[2][2])/3]}get_node(){let e=new h;for(let t=0;t<3;t++)o.jk(e.minCorner,e.minCorner,this.corners[t]),o.T9(e.maxCorner,e.maxCorner,this.corners[t]);return e}}class d{constructor(e){this.indices=new Array(e.length);for(var t=0;t<e.length;t+=1)this.indices[t]=t;for(this.nodes=new Array(2*e.length-1),t=0;t<2*e.length-1;t+=1)this.nodes[t]=new h;var n=this.nodes[0];n.leftChild=0,n.primitiveCount=e.length,this.nodes_used=1,this.update_bounds(0,e),this.subdivide(0,e)}update_bounds(e,t){var n=this.nodes[e];n.minCorner=[1e30,1e30,1e30],n.maxCorner=[-1e30,-1e30,-1e30];for(var r=0;r<n.primitiveCount;r+=1){const e=t[this.indices[n.leftChild+r]];o.jk(n.minCorner,n.minCorner,e.minCorner),o.T9(n.maxCorner,n.maxCorner,e.maxCorner)}}subdivide(e,t){var n=this.nodes[e];if(n.primitiveCount<2)return;var r=[0,0,0];o.Re(r,n.maxCorner,n.minCorner);var i=0;r[1]>r[i]&&(i=1),r[2]>r[i]&&(i=2);const s=n.minCorner[i]+r[i]/2;for(var a=n.leftChild,h=a+n.primitiveCount-1;a<=h;){let e=t[this.indices[a]];if(.5*(e.minCorner[i]+e.maxCorner[i])<s)a+=1;else{var c=this.indices[a];this.indices[a]=this.indices[h],this.indices[h]=c,h-=1}}var d=a-n.leftChild;if(0==d||d==n.primitiveCount)return;const l=this.nodes_used;this.nodes_used+=1;const u=this.nodes_used;this.nodes_used+=1,this.nodes[l].leftChild=n.leftChild,this.nodes[l].primitiveCount=d,this.nodes[u].leftChild=a,this.nodes[u].primitiveCount=n.primitiveCount-d,n.leftChild=l,n.primitiveCount=0,this.update_bounds(l,t),this.update_bounds(u,t),this.subdivide(l,t),this.subdivide(u,t)}get_flattened_nodes(e){let t=new Float32Array(8*this.nodes.length);for(let n=0;n<this.nodes.length;n++){this.nodes[n].flatten();let r=this.nodes[n].data[7]>0;this.nodes[n].data[3]+=r?e[1]:e[0];let i=8*n;for(let e=0;e<8;e++)t[i+e]=this.nodes[n].data[e]}return t}get_flattened_indices(e){let t=new Float32Array(this.indices.length);for(let n=0;n<this.indices.length;n++)t[n]=this.indices[n]+e[0];return t}}class l{constructor(){this.v=[],this.vt=[],this.vn=[],this.triangles=[],this.minCorner=[1e30,1e30,1e30],this.maxCorner=[-1e30,-1e30,-1e30]}async initialize(e,t){this.color=e,await this.readFile(t),this.v=[],this.vt=[],this.vn=[],this.build_bvh()}async readFile(e){var t=[];const n=await fetch(e),r=await n.blob();(await r.text()).split("\n").forEach((e=>{"v"==e[0]&&" "==e[1]?this.read_vertex_data(e):"v"==e[0]&&"t"==e[1]?this.read_texcoord_data(e):"v"==e[0]&&"n"==e[1]?this.read_normal_data(e):"f"==e[0]&&this.read_face_data(e,t)}))}read_vertex_data(e){const t=e.split(" "),n=[Number(t[1]).valueOf(),Number(t[2]).valueOf(),Number(t[3]).valueOf()];this.v.push(n),o.jk(this.minCorner,this.minCorner,n),o.T9(this.maxCorner,this.maxCorner,n)}read_texcoord_data(e){const t=e.split(" "),n=[Number(t[1]).valueOf(),Number(t[2]).valueOf()];this.vt.push(n)}read_normal_data(e){const t=e.split(" "),n=[Number(t[1]).valueOf(),Number(t[2]).valueOf(),Number(t[3]).valueOf()];this.vn.push(n)}read_face_data(e,t){const n=(e=e.replace("\n","")).split(" "),r=n.length-3;for(var i=0;i<r;i++){var s=new c;this.read_corner(n[1+2*i],s),this.read_corner(n[2+2*i],s),i%3?this.read_corner(n[1],s):this.read_corner(n[3+2*i],s),s.color=this.color,s.make_centroid(),this.triangles.push(s)}}read_corner(e,t){const n=e.split("/"),r=this.v[Number(n[0]).valueOf()-1],i=(this.vt[Number(n[1]).valueOf()-1],this.vn[Number(n[2]).valueOf()-1]);t.corners.push(r),t.normals.push(i)}build_bvh(){let e=new Array(this.triangles.length);for(let t=0;t<this.triangles.length;t++)e[t]=this.triangles[t].get_node();this.bvh=new d(e)}get_node(){let e=new h;return o.jk(e.minCorner,e.minCorner,this.minCorner),o.T9(e.maxCorner,e.maxCorner,this.maxCorner),e}}var u=n(684);class f{constructor(e,t,n){this.inverseModel=u.vt(),this.minCorner=[1e30,1e30,1e30],this.maxCorner=[-1e30,-1e30,-1e30];var r=o.vt();const i=[[e.minCorner[0],e.minCorner[1],e.minCorner[2]],[e.minCorner[0],e.minCorner[1],e.maxCorner[2]],[e.minCorner[0],e.maxCorner[1],e.minCorner[2]],[e.minCorner[0],e.maxCorner[1],e.maxCorner[2]],[e.maxCorner[0],e.minCorner[1],e.minCorner[2]],[e.maxCorner[0],e.minCorner[1],e.maxCorner[2]],[e.maxCorner[0],e.maxCorner[1],e.minCorner[2]],[e.maxCorner[0],e.maxCorner[1],e.maxCorner[2]]];for(let e=0;e<8;e++)o.Z0(r,i[e],t),o.jk(this.minCorner,this.minCorner,r),o.T9(this.maxCorner,this.maxCorner,r);this.center=[(this.minCorner[0]+this.maxCorner[0])/2,(this.minCorner[1]+this.maxCorner[1])/2,(this.minCorner[2]+this.maxCorner[2])/2],this.inverseModel=this.fast_inverse(t),this.data=new Float32Array(20);for(let e=0;e<16;e++)this.data[e]=this.inverseModel.at(e);this.data[16]=n,this.data[17]=n,this.data[18]=n,this.data[19]=n}fast_inverse(e){let t=u.vt(),n=[];for(let t=0;t<4;++t)n.push([e[4*t],e[4*t+1],e[4*t+2]]);for(let e=0;e<3;++e)for(let r=0;r<3;++r)t[e+4*r]=n[e][r];for(let e=0;e<3;++e)t[e+12]=-o.Om(n[e],n[3]);return t}get_node(){let e=new h;return e.minCorner=this.minCorner,e.maxCorner=this.maxCorner,e}}class m{constructor(e,t){this.loaded=!1,this.render=()=>{let e=performance.now();this.scene.update(this.frametime),this.prepareScene();const t=this.device.createCommandEncoder(),n=t.beginComputePass();n.setPipeline(this.ray_tracing_pipeline.pipeline),n.setBindGroup(0,this.ray_tracing_bind_group),n.dispatchWorkgroups(this.canvas.width/8,this.canvas.height/8,1),n.end();const r=this.context.getCurrentTexture().createView(),i=t.beginRenderPass({colorAttachments:[{view:r,clearValue:{r:.5,g:0,b:.25,a:1},loadOp:"clear",storeOp:"store"}]});i.setPipeline(this.screen_pipeline.pipeline),i.setBindGroup(0,this.screen_bind_group),i.draw(6,1,0,0),i.end(),this.device.queue.submit([t.finish()]),this.device.queue.onSubmittedWorkDone().then((()=>{let t=performance.now();this.frametime=t-e;let n=document.getElementById("render-time");n&&(n.innerText=this.frametime.toString())})),requestAnimationFrame(this.render)},this.canvas=e,this.scene=t,this.statue_mesh=new l}async Initialize(){await this.setupDevice(),this.ray_tracing_pipeline=new i(this.device,GPUShaderStage.COMPUTE),this.screen_pipeline=new i(this.device,GPUShaderStage.FRAGMENT),await this.makeBindGroupLayouts(),await this.createAssets(),await this.makeBindGroups(),await this.makePipelines(),this.frametime=16,this.render()}async setupDevice(){var e,t;this.adapter=await(null===(e=navigator.gpu)||void 0===e?void 0:e.requestAdapter()),this.device=await(null===(t=this.adapter)||void 0===t?void 0:t.requestDevice()),this.context=this.canvas.getContext("webgpu"),this.format="bgra8unorm",this.context.configure({device:this.device,format:this.format,alphaMode:"opaque"})}async makeBindGroupLayouts(){this.ray_tracing_pipeline.addImage2D(),this.ray_tracing_pipeline.addBuffer("uniform"),this.ray_tracing_pipeline.addBuffer("read-only-storage"),this.ray_tracing_pipeline.addBuffer("read-only-storage"),this.ray_tracing_pipeline.addBuffer("read-only-storage"),this.ray_tracing_pipeline.addBuffer("read-only-storage"),this.ray_tracing_pipeline.addImageCube(),await this.ray_tracing_pipeline.makeBindGroupLayout(),this.screen_pipeline.addImage2D(),await this.screen_pipeline.makeBindGroupLayout()}async createAssets(){this.color_buffer=this.device.createTexture({size:{width:this.canvas.width,height:this.canvas.height},format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.color_buffer_view=this.color_buffer.createView(),this.sampler=this.device.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"nearest",mipmapFilter:"nearest",maxAnisotropy:1}),this.sceneParameters=new a(this.device),this.sceneParameters.add_coarse_partition(64,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM),this.sceneParameters.Initialize(),await this.statue_mesh.initialize([1,1,1],"dist/models/statue.obj");let e=new Array(this.scene.objects.length),t=this.statue_mesh.get_node(),n=2*this.scene.objects.length-1;for(let r=0;r<this.scene.objects.length;++r)e[r]=new f(t,this.scene.objects[r].model,n).get_node();this.tlas=new d(e);let i=2*this.scene.objects.length-1,s=this.scene.objects.length,o=this.statue_mesh.bvh.nodes.length,h=this.statue_mesh.bvh.indices.length,c=8*(i+o),l=s+h;this.bvh_buffer=new a(this.device),this.bvh_buffer.add_coarse_partition(4*c,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.bvh_buffer.add_coarse_partition(4*l,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.bvh_buffer.Initialize();let u=0,m=8*i,_=[0,0];this.bvh_buffer.add_fine_partition(u,m,_),m=8*o,_=[i,s],this.bvh_buffer.add_fine_partition(u,m,_),u=1,m=s,_=[0],this.bvh_buffer.add_fine_partition(u,m,_),m=h,_=[0],this.bvh_buffer.add_fine_partition(u,m,_),u=0;let p=this.bvh_buffer.get_fine_partition(u,1);_=p.payload;let v=this.statue_mesh.bvh.get_flattened_nodes(_);this.bvh_buffer.blit_to_fine_partition(u,1,v),this.bvh_buffer.upload_fine_partition(u,1),u=1,p=this.bvh_buffer.get_fine_partition(u,1),_=p.payload;let b=this.statue_mesh.bvh.get_flattened_indices(_);this.bvh_buffer.blit_to_fine_partition(u,1,b),this.bvh_buffer.upload_fine_partition(u,1),this.triangleBuffer=new a(this.device),this.triangleBuffer.add_coarse_partition(112*this.statue_mesh.triangles.length,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.triangleBuffer.Initialize();let g=0;u=0;for(let e=0;e<this.statue_mesh.triangles.length;e++)this.statue_mesh.triangles[e].flatten(),this.triangleBuffer.blit_to_coarse_partition(u,this.statue_mesh.triangles[e].data,g),g+=28;this.triangleBuffer.upload_coarse_partition(u),this.blasDescriptionBuffer=new a(this.device),this.blasDescriptionBuffer.add_coarse_partition(80*this.scene.objects.length,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.blasDescriptionBuffer.Initialize(),this.sky_texture=new r,await this.sky_texture.initialize(this.device,["dist/gfx/sky_front.png","dist/gfx/sky_back.png","dist/gfx/sky_left.png","dist/gfx/sky_right.png","dist/gfx/sky_bottom.png","dist/gfx/sky_top.png"])}async makeBindGroups(){this.ray_tracing_bind_group=this.device.createBindGroup({layout:this.ray_tracing_pipeline.bind_group_layout,entries:[{binding:0,resource:this.color_buffer_view},{binding:1,resource:{buffer:this.sceneParameters.deviceMemory}},{binding:2,resource:{buffer:this.triangleBuffer.deviceMemory}},{binding:3,resource:{label:"BVH Node buffer",buffer:this.bvh_buffer.deviceMemory,offset:this.bvh_buffer.get_coarse_partition(0).offset}},{binding:4,resource:{buffer:this.blasDescriptionBuffer.deviceMemory}},{binding:5,resource:{label:"BVH Index buffer",buffer:this.bvh_buffer.deviceMemory,offset:this.bvh_buffer.get_coarse_partition(1).offset}},{binding:6,resource:this.sky_texture.view},{binding:7,resource:this.sky_texture.sampler}]}),this.screen_bind_group=this.device.createBindGroup({layout:this.screen_pipeline.bind_group_layout,entries:[{binding:0,resource:this.sampler},{binding:1,resource:this.color_buffer_view}]})}async makePipelines(){await this.ray_tracing_pipeline.build("struct Sphere {\n    center: vec3<f32>,\n    color: vec3<f32>,\n    radius: f32,\n}\n\nstruct Triangle {\n    corner_a: vec3<f32>,\n    //float\n    normal_a: vec3<f32>,\n    //float\n    corner_b: vec3<f32>,\n    //float\n    normal_b: vec3<f32>,\n    //float\n    corner_c: vec3<f32>,\n    //float\n    normal_c: vec3<f32>,\n    //float\n    color: vec3<f32>,\n    //float\n}\n\nstruct PrimitiveData {\n    triangles: array<Triangle>,\n}\n\nstruct Node {\n    minCorner: vec3<f32>,\n    leftChild: f32,\n    maxCorner: vec3<f32>,\n    primitiveCount: f32,\n}\n\nstruct blasDescription {\n    inverseModel: mat4x4<f32>,\n    rootNodeIndex: vec4<f32>,\n}\n\nstruct BVH {\n    nodes: array<Node>,\n}\n\nstruct blasDescriptions {\n    descriptions: array<blasDescription>,\n}\n\nstruct ObjectIndices {\n    indices: array<f32>,\n}\n\nstruct Ray {\n    direction: vec3<f32>,\n    origin: vec3<f32>,\n}\n\nstruct SceneData {\n    cameraPos: vec3<f32>,\n    cameraForwards: vec3<f32>,\n    cameraRight: vec3<f32>,\n    maxBounces: f32,\n    cameraUp: vec3<f32>,\n}\n\nstruct RenderState {\n    color: vec3<f32>,\n    t: f32,\n    normal: vec3<f32>,\n    hit: bool,\n}\n\n@group(0) @binding(0) var color_buffer: texture_storage_2d<rgba8unorm, write>;\n@group(0) @binding(1) var<uniform> scene: SceneData;\n@group(0) @binding(2) var<storage, read> objects: PrimitiveData;\n@group(0) @binding(3) var<storage, read> tree: BVH;\n@group(0) @binding(4) var<storage, read> blas: blasDescriptions;\n@group(0) @binding(5) var<storage, read> lookup: ObjectIndices;\n@group(0) @binding(6) var skyTexture: texture_cube<f32>;\n@group(0) @binding(7) var skySampler: sampler;\n\nconst epsilon: f32 = 0.0000001;\n\n@compute @workgroup_size(8,8,1)\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\n\n    let screen_size: vec2<i32> = vec2<i32>(textureDimensions(color_buffer));\n    let screen_pos : vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));\n\n    let horizontal_coefficient: f32 = (f32(screen_pos.x) - f32(screen_size.x) / 2) / f32(screen_size.x);\n    let vertical_coefficient: f32 = (f32(screen_pos.y) - f32(screen_size.y) / 2) / f32(screen_size.x);\n\n    let forwards: vec3<f32> = scene.cameraForwards;\n    let right: vec3<f32> = scene.cameraRight;\n    let up: vec3<f32> = scene.cameraUp;\n\n    var myRay: Ray;\n    myRay.direction = normalize(forwards + horizontal_coefficient * right + vertical_coefficient * up);\n    myRay.origin = scene.cameraPos;\n\n    let pixel_color : vec3<f32> = rayColor(myRay);\n\n    textureStore(color_buffer, screen_pos, vec4<f32>(pixel_color, 1.0));\n}\n\nfn rayColor(ray: Ray) -> vec3<f32> {\n\n    var color: vec3<f32> = vec3(1.0, 1.0, 1.0);\n    var result: RenderState;\n\n    var world_ray: Ray;\n    world_ray.origin = ray.origin;\n    world_ray.direction = ray.direction;\n\n    let bounces: u32 = u32(scene.maxBounces);\n    for(var bounce: u32 = 0; bounce < bounces; bounce++) {\n\n        result = trace_tlas(world_ray);\n\n        if (!result.hit) {\n            //sky color\n            color = color * textureSampleLevel(skyTexture, skySampler, world_ray.direction, 0.0).xyz;\n            break;\n        }\n\n        //unpack color\n        color = color * result.color;\n\n        //Set up for next trace\n        world_ray.origin = world_ray.origin + result.t * world_ray.direction;\n        world_ray.direction = normalize(reflect(world_ray.direction, result.normal));\n    }\n\n    //Rays which reached terminal state and bounced indefinitely\n    if (result.hit) {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n\n    return color;\n}\n\nfn trace_tlas(ray: Ray) -> RenderState {\n\n    //Set up the Render State\n    var renderState: RenderState;\n    renderState.hit = false;\n    var nearestHit: f32 = 9999;\n\n    //Set up for BVH Traversal\n    var node: Node = tree.nodes[0];\n    var stack: array<Node, 20>;\n    var stackLocation: u32 = 0;\n\n    while (true) {\n\n        var primitiveCount: u32 = u32(node.primitiveCount);\n        var contents: u32 = u32(node.leftChild);\n\n        if (primitiveCount == 0) {\n            var child1: Node = tree.nodes[contents];\n            var child2: Node = tree.nodes[contents + 1];\n\n            var distance1: f32 = hit_aabb(ray, child1);\n            var distance2: f32 = hit_aabb(ray, child2);\n            if (distance1 > distance2) {\n                var tempDist: f32 = distance1;\n                distance1 = distance2;\n                distance2 = tempDist;\n\n                var tempChild: Node = child1;\n                child1 = child2;\n                child2 = tempChild;\n            }\n\n            if (distance1 > nearestHit) {\n                if (stackLocation == 0) {\n                    break;\n                }\n                else {\n                    stackLocation -= 1;\n                    node = stack[stackLocation];\n                }\n            }\n            else {\n                node = child1;\n                if (distance2 < nearestHit) {\n                    stack[stackLocation] = child2;\n                    stackLocation += 1;\n                }\n            }\n        }\n        else {\n            for (var i: u32 = 0; i < primitiveCount; i++) {\n        \n                var newRenderState: RenderState = trace_blas(\n                    ray, \n                    blas.descriptions[u32(lookup.indices[i + contents])], \n                    nearestHit,\n                    renderState\n                );\n\n                if (newRenderState.hit) {\n                    nearestHit = newRenderState.t;\n                    renderState = newRenderState;\n                }\n            }\n\n            if (stackLocation == 0) {\n                break;\n            }\n            else {\n                stackLocation -= 1;\n                node = stack[stackLocation];\n            }\n        }\n    }\n\n    return renderState;\n}\n\nfn trace_blas(\n    ray: Ray, \n    description: blasDescription,\n    nearestHit: f32,\n    renderState: RenderState) -> RenderState {\n\n    var object_ray: Ray;\n    object_ray.origin = (description.inverseModel * vec4<f32>(ray.origin, 1.0)).xyz;\n    object_ray.direction = (description.inverseModel * vec4<f32>(ray.direction, 0.0)).xyz;\n\n    //Set up the Render State\n    var blasRenderState: RenderState;\n    blasRenderState.t = renderState.t;\n    blasRenderState.normal = renderState.normal;\n    blasRenderState.color = renderState.color;\n    blasRenderState.hit = false;\n\n    var blasNearestHit: f32 = nearestHit;\n\n    //Set up for BVH Traversal\n    var node: Node = tree.nodes[u32(description.rootNodeIndex.x)];\n    var stack: array<Node, 20>;\n    var stackLocation: u32 = 0;\n\n    while (true) {\n\n        var primitiveCount: u32 = u32(node.primitiveCount);\n        var contents: u32 = u32(node.leftChild);\n\n        if (primitiveCount == 0) {\n            var child1: Node = tree.nodes[contents];\n            var child2: Node = tree.nodes[contents + 1];\n\n            var distance1: f32 = hit_aabb(object_ray, child1);\n            var distance2: f32 = hit_aabb(object_ray, child2);\n            if (distance1 > distance2) {\n                var tempDist: f32 = distance1;\n                distance1 = distance2;\n                distance2 = tempDist;\n\n                var tempChild: Node = child1;\n                child1 = child2;\n                child2 = tempChild;\n            }\n\n            if (distance1 > blasNearestHit) {\n                if (stackLocation == 0) {\n                    break;\n                }\n                else {\n                    stackLocation -= 1;\n                    node = stack[stackLocation];\n                }\n            }\n            else {\n                node = child1;\n                if (distance2 < blasNearestHit) {\n                    stack[stackLocation] = child2;\n                    stackLocation += 1;\n                }\n            }\n        }\n        else {\n            for (var i: u32 = 0; i < primitiveCount; i++) {\n        \n                var newRenderState: RenderState = hit_triangle(\n                    object_ray, \n                    objects.triangles[u32(lookup.indices[i + contents])], \n                    epsilon, blasNearestHit, blasRenderState\n                );\n\n                if (newRenderState.hit) {\n                    blasNearestHit = newRenderState.t;\n                    blasRenderState = newRenderState;\n                }\n            }\n\n            if (stackLocation == 0) {\n                break;\n            }\n            else {\n                stackLocation -= 1;\n                node = stack[stackLocation];\n            }\n        }\n    }\n\n    if (blasRenderState.hit) {\n        blasRenderState.normal = normalize(\n            (transpose(description.inverseModel) * vec4(blasRenderState.normal, 0.0)).xyz\n        );\n    }\n\n    return blasRenderState;\n}\n\nfn hit_sphere(ray: Ray, sphere: Sphere, tMin: f32, oldRenderState: RenderState) -> RenderState {\n    \n    let co: vec3<f32> = ray.origin - sphere.center;\n    let a: f32 = dot(ray.direction, ray.direction);\n    let b: f32 = 2.0 * dot(ray.direction, co);\n    let c: f32 = dot(co, co) - sphere.radius * sphere.radius;\n    let discriminant: f32 = b * b - 4.0 * a * c;\n\n    var renderState: RenderState;\n    renderState.color = oldRenderState.color;\n\n    if (discriminant > 0.0) {\n\n        let t: f32 = (-b - sqrt(discriminant)) / (2 * a);\n\n        if (t > tMin && t < oldRenderState.t) {\n            renderState.t = t;\n            renderState.color = sphere.color;\n            renderState.hit = true;\n            return renderState;\n        }\n    }\n\n    renderState.hit = false;\n    return renderState;\n    \n}\n\nfn hit_triangle(\n    ray: Ray, tri: Triangle, \n    tMin: f32, tMax:f32,\n    oldRenderState: RenderState) -> RenderState {\n\n    var renderState: RenderState;\n    renderState.color = oldRenderState.color;\n    renderState.hit = false;\n\n    //Direction vectors\n    let edge_ab: vec3<f32> = tri.corner_b - tri.corner_a;\n    let edge_ac: vec3<f32> = tri.corner_c - tri.corner_a;\n    //Normal of the triangle\n    var n: vec3<f32> = normalize(cross(edge_ab, edge_ac));\n    var ray_dot_tri: f32 = dot(ray.direction, n);\n    //backface reversal\n    if (ray_dot_tri > 0.0) {\n        //ray_dot_tri = ray_dot_tri * -1;\n        //n = n * -1;\n        return renderState;\n    }\n    //early exit, ray parallel with triangle surface\n    if (abs(ray_dot_tri) < epsilon) {\n        return renderState;\n    }\n\n    var system_matrix: mat3x3<f32> = mat3x3<f32>(\n        ray.direction,\n        tri.corner_a - tri.corner_b,\n        tri.corner_a - tri.corner_c\n    );\n    let denominator: f32 = determinant(system_matrix);\n    if (abs(denominator) < epsilon) {\n        return renderState;\n    }\n\n    system_matrix = mat3x3<f32>(\n        ray.direction,\n        tri.corner_a - ray.origin,\n        tri.corner_a - tri.corner_c\n    );\n    let u: f32 = determinant(system_matrix) / denominator;\n    \n    if (u < 0.0 || u > 1.0) {\n        return renderState;\n    }\n\n    system_matrix = mat3x3<f32>(\n        ray.direction,\n        tri.corner_a - tri.corner_b,\n        tri.corner_a - ray.origin,\n    );\n    let v: f32 = determinant(system_matrix) / denominator;\n    if (v < 0.0 || u + v > 1.0) {\n        return renderState;\n    }\n\n    system_matrix = mat3x3<f32>(\n        tri.corner_a - ray.origin,\n        tri.corner_a - tri.corner_b,\n        tri.corner_a - tri.corner_c\n    );\n    let t: f32 = determinant(system_matrix) / denominator;\n\n    if (t > tMin && t < tMax) {\n        renderState.normal = (1.0 - u - v) * tri.normal_a + u * tri.normal_b + v * tri.normal_c;\n        renderState.color = tri.color;\n        renderState.t = t;\n        renderState.hit = true;\n        return renderState;\n    }\n\n    return renderState;\n}\n\nfn hit_aabb(ray: Ray, node: Node) -> f32 {\n\n    var inverseDir: vec3<f32> = vec3(1.0) / ray.direction;\n    var t1: vec3<f32> = (node.minCorner - ray.origin) * inverseDir;\n    var t2: vec3<f32> = (node.maxCorner - ray.origin) * inverseDir;\n    var tMin: vec3<f32> = min(t1, t2);\n    var tMax: vec3<f32> = max(t1, t2);\n\n    var t_min: f32 = max(max(tMin.x, tMin.y), tMin.z);\n    var t_max: f32 = min(min(tMax.x, tMax.y), tMax.z);\n\n    if (t_min > t_max || t_max < 0) {\n        return 99999;\n    }\n    else {\n        return t_min;\n    }\n}",["main"]),await this.screen_pipeline.build("@group(0) @binding(0) var screen_sampler : sampler;\r\n@group(0) @binding(1) var color_buffer : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n    @builtin(position) Position : vec4<f32>,\r\n    @location(0) TexCoord : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vert_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n\r\n    var positions = array<vec2<f32>, 6>(\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>( 1.0, -1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>(-1.0,  1.0)\r\n    );\r\n\r\n    var texCoords = array<vec2<f32>, 6>(\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(1.0, 1.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(0.0, 0.0)\r\n    );\r\n\r\n    var output : VertexOutput;\r\n    output.Position = vec4<f32>(positions[VertexIndex], 0.0, 1.0);\r\n    output.TexCoord = texCoords[VertexIndex];\r\n    return output;\r\n}\r\n\r\n@fragment\r\nfn frag_main(@location(0) TexCoord : vec2<f32>) -> @location(0) vec4<f32> {\r\n  return textureSample(color_buffer, screen_sampler, TexCoord);\r\n}",["vert_main","frag_main"])}prepareScene(){let e=0;this.sceneParameters.blit_to_coarse_partition(e,this.scene.camera.data,0),this.sceneParameters.upload_coarse_partition(e);let t=0,n=this.statue_mesh.get_node(),r=this.bvh_buffer.get_fine_partition(0,1).offset/8,i=new Array(this.scene.objects.length);for(let s=0;s<this.scene.objects.length;s++){let a=new f(n,this.scene.objects[s].model,r);this.blasDescriptionBuffer.blit_to_coarse_partition(e,a.data,t),t+=20,i[s]=a.get_node()}this.blasDescriptionBuffer.upload_coarse_partition(e),this.tlas=new d(i);let s=this.bvh_buffer.get_fine_partition(e,0).payload,a=this.tlas.get_flattened_nodes(s);this.bvh_buffer.blit_to_fine_partition(e,0,a),this.bvh_buffer.upload_fine_partition(e,0),e=1,s=this.bvh_buffer.get_fine_partition(e,0).payload;let o=this.tlas.get_flattened_indices(s);this.bvh_buffer.blit_to_fine_partition(e,0,o),this.bvh_buffer.upload_fine_partition(e,0),this.loaded||(this.loaded=!0)}}},195:(e,t,n)=>{n.d(t,{Z:()=>C});var r=n(329);function i(e){return e*Math.PI/180}class s{constructor(e,t){this.position=new Float32Array(e),this.theta=0,this.phi=0,this.data=new Float32Array(16),this.data[11]=t,this.recalculate_vectors()}recalculate_vectors(){this.forwards=new Float32Array([Math.cos(i(this.theta))*Math.cos(i(this.phi)),Math.sin(i(this.theta))*Math.cos(i(this.phi)),Math.sin(i(this.theta))]),this.right=new Float32Array([0,0,0]),r.$A(this.right,this.forwards,[0,0,1]),this.up=new Float32Array([0,0,0]),r.$A(this.up,this.right,this.forwards),this.data[0]=this.position[0],this.data[1]=this.position[1],this.data[2]=this.position[2],this.data[4]=this.forwards[0],this.data[5]=this.forwards[1],this.data[6]=this.forwards[2],this.data[8]=this.right[0],this.data[9]=this.right[1],this.data[10]=this.right[2],this.data[12]=this.up[0],this.data[13]=this.up[1],this.data[14]=this.up[2]}}var a=n(684);class o{constructor(e,t,n){this.position=e,this.eulers=t,this.angular_velocity=n,this.calculate_transform()}update(e){let t=[0,0,0];r.hs(t,this.angular_velocity,.1*e),r.WQ(this.eulers,this.eulers,t);for(let e=0;e<3;e++)this.eulers[e]>360?this.eulers[e]-=360:this.eulers[e]<0&&(this.eulers[e]+=360);this.calculate_transform()}calculate_transform(){this.model=a.vt(),a.Tl(this.model,this.model,this.position),a.Qr(this.model,this.model,i(this.eulers[2])),a.eL(this.model,this.model,i(this.eulers[1])),a.eL(this.model,this.model,i(this.eulers[0]))}}var h=Object.defineProperty,c=(e,t,n)=>((e,t,n)=>t in e?h(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n)(e,"symbol"!=typeof t?t+"":t,n),d=class{},l=class e extends d{constructor(e){var t;super(),c(this,"_name"),c(this,"_rngFn"),this._name=null!=(t=e.name)?t:"function",this._rngFn=e}get name(){return this._name}next(){return this._rngFn()}clone(){return new e(this._rngFn)}};function u(e){switch(typeof e){case"object":if(e instanceof d)return e;break;case"function":return new l(e);default:return new f(e)}throw new Error(`invalid RNG seed or instance "${e}"`)}var f=class e extends d{constructor(e){super(),c(this,"_seed"),c(this,"i"),c(this,"j"),c(this,"S");const t=function(e){if(void 0===e&&(e=crypto.randomUUID()),"number"==typeof e)return e;const t=`${e}`;let n=0;for(let e=0;e<t.length;++e)n^=0|t.charCodeAt(e);return n}(e);this._seed=t;const n=function(e,t){var n;const r=`${e}`;let i=0,s=0;for(;s<r.length;)t[255&s]=255&(i^=19*(null!=(n=t[255&s])?n:0))+r.charCodeAt(s++);return t.length?t:[0]}(t,[]),r=[],i=n.length;this.i=0,this.j=0,this.S=r;let s=0;for(;s<=255;)r[s]=s++;for(let e=0,t=0;e<=255;e++){const s=r[e];t=255&t+n[e%i]+s,r[e]=r[t],r[t]=s}this.g(256)}get name(){return"arc4"}next(){let e=this.g(6),t=281474976710656,n=0;for(;e<4503599627370496;)e=256*(e+n),t*=256,n=this.g(1);for(;e>=9007199254740992;)e/=2,t/=2,n>>>=1;return(e+n)/t}g(e){const{S:t}=this;let{i:n,j:r}=this,i=0;for(;e--;){n=255&n+1;const e=t[n];t[r]=e,r=255&r+e,t[n]=t[r],i=256*i+t[255&t[n]+e]}return this.i=n,this.j=r,i}clone(){return new e(this._seed)}},m=class e extends d{get name(){return"Math.random"}next(){return Math.random()}clone(){return new e}};function _(e){return new p(e)}var p=class{constructor(e){c(this,"n"),c(this,"isInt",(()=>{if(Number.isInteger(this.n))return this;throw new Error(`Expected number to be an integer, got ${this.n}`)})),c(this,"isPositive",(()=>{if(this.n>0)return this;throw new Error(`Expected number to be positive, got ${this.n}`)})),c(this,"lessThan",(e=>{if(this.n<e)return this;throw new Error(`Expected number to be less than ${e}, got ${this.n}`)})),c(this,"greaterThanOrEqual",(e=>{if(this.n>=e)return this;throw new Error(`Expected number to be greater than or equal to ${e}, got ${this.n}`)})),c(this,"greaterThan",(e=>{if(this.n>e)return this;throw new Error(`Expected number to be greater than ${e}, got ${this.n}`)})),this.n=e}},v=[0,0,.6931471805599453,1.791759469228055,3.1780538303479458,4.787491742782046,6.579251212010101,8.525161361065415,10.60460290274525,12.801827480081469],b=e=>v[e];function g(e,t=0,n=1){return()=>e.next()*(n-t)+t}function y(e){return()=>e.next()>=.5}function x(e,t=0,n=1){return void 0===n&&(n=void 0===t?1:t,t=0),_(t).isInt(),_(n).isInt(),()=>Math.floor(e.next()*(n-t+1)+t)}var w=class e{constructor(e=new m){c(this,"_rng"),c(this,"_cache",{}),c(this,"next",(()=>this._rng.next())),c(this,"float",((e,t)=>this.uniform(e,t)())),c(this,"int",((e,t)=>this.uniformInt(e,t)())),c(this,"integer",((e,t)=>this.uniformInt(e,t)())),c(this,"bool",(()=>this.uniformBoolean()())),c(this,"boolean",(()=>this.uniformBoolean()())),c(this,"uniform",((e,t)=>this._memoize("uniform",g,e,t))),c(this,"uniformInt",((e,t)=>this._memoize("uniformInt",x,e,t))),c(this,"uniformBoolean",(()=>this._memoize("uniformBoolean",y))),c(this,"normal",((e,t)=>function(e,t=0,n=1){return()=>{let r,i,s;do{r=2*e.next()-1,i=2*e.next()-1,s=r*r+i*i}while(!s||s>1);return t+n*i*Math.sqrt(-2*Math.log(s)/s)}}(this,e,t))),c(this,"logNormal",((e,t)=>function(e,t=0,n=1){const r=e.normal(t,n);return()=>Math.exp(r())}(this,e,t))),c(this,"bernoulli",(e=>function(e,t=.5){return _(t).greaterThanOrEqual(0).lessThan(1),()=>Math.floor(e.next()+t)}(this,e))),c(this,"binomial",((e,t)=>function(e,t=1,n=.5){return _(t).isInt().isPositive(),_(n).greaterThanOrEqual(0).lessThan(1),()=>{let r=0,i=0;for(;r++<t;)e.next()<n&&i++;return i}}(this,e,t))),c(this,"geometric",(e=>function(e,t=.5){_(t).greaterThan(0).lessThan(1);const n=1/Math.log(1-t);return()=>Math.floor(1+Math.log(e.next())*n)}(this,e))),c(this,"poisson",(e=>function(e,t=1){if(_(t).isPositive(),t<10){const n=Math.exp(-t);return()=>{let r=n,i=0,s=e.next();for(;s>r;)s-=r,r=t*r/++i;return i}}{const n=Math.sqrt(t),r=.931+2.53*n,i=.02483*r-.059,s=1.1239+1.1328/(r-3.4),a=.9277-3.6224/(r-2);return()=>{for(var o;;){let h,c=e.next();if(c<=.86*a)return h=c/a-.43,Math.floor((2*i/(.5-Math.abs(h))+r)*h+t+.445);c>=a?h=e.next()-.5:(h=c/a-.93,h=(h<0?-.5:.5)-h,c=e.next()*a);const d=.5-Math.abs(h);if(d<.013&&c>d)continue;const l=Math.floor((2*i/d+r)*h+t+.445);if(c=c*s/(i/(d*d)+r),l>=10){const e=(l+.5)*Math.log(t/l)-t-.9189385332046727+l-(1/12-(1/360-1/(1260*l*l))/(l*l))/l;if(Math.log(c*n)<=e)return l}else if(l>=0){const e=null!=(o=b(l))?o:0;if(Math.log(c)<=l*Math.log(t)-t-e)return l}}}}}(this,e))),c(this,"exponential",(e=>function(e,t=1){return _(t).isPositive(),()=>-Math.log(1-e.next())/t}(this,e))),c(this,"irwinHall",(e=>function(e,t=1){return _(t).isInt().greaterThanOrEqual(0),()=>{let n=0;for(let r=0;r<t;++r)n+=e.next();return n}}(this,e))),c(this,"bates",(e=>function(e,t=1){_(t).isInt().isPositive();const n=e.irwinHall(t);return()=>n()/t}(this,e))),c(this,"pareto",(e=>function(e,t=1){_(t).greaterThanOrEqual(0);const n=1/t;return()=>1/Math.pow(1-e.next(),n)}(this,e))),this._rng=u(e)}get rng(){return this._rng}clone(t=this.rng.clone()){return new e(t)}use(e){this._rng=u(e)}choice(e){if(!Array.isArray(e))throw new TypeError("Random.choice expected input to be an array, got "+typeof e);const t=e.length;if(t>0)return e[this.uniformInt(0,t-1)()]}_memoize(e,t,...n){const r=`${n.join(";")}`;let i=this._cache[e];return void 0!==i&&i.key===r||(i={key:r,distribution:t(this,...n)},this._cache[e]=i),i.distribution}};new w;class C{constructor(){this.debugMode=!1,this.objects=new Array;let e=new w;for(let t=0;t<100;t++){let t=e.float(-10,10),n=e.float(-10,10),r=e.float(-10,10),i=[t,n,r];t=e.float(0,360),n=e.float(0,360),r=e.float(0,360);let s=[t,n,r];t=e.float(-.2,.2),n=e.float(-.2,.2),r=e.float(-.2,.2);let a=[t,n,r];this.objects.push(new o(i,s,a))}this.camera=new s([-6,0,-1],4)}update(e){this.objects.forEach((t=>{t.update(e/16.667)}))}}}},s={};function a(e){var t=s[e];if(void 0!==t)return t.exports;var n=s[e]={exports:{}};return i[e](n,n.exports,a),n.exports}e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",t="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",n="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",r=e=>{e&&e.d<1&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},a.a=(i,s,a)=>{var o;a&&((o=[]).d=-1);var h,c,d,l=new Set,u=i.exports,f=new Promise(((e,t)=>{d=t,c=e}));f[t]=u,f[e]=e=>(o&&e(o),l.forEach(e),f.catch((e=>{}))),i.exports=f,s((i=>{var s;h=(i=>i.map((i=>{if(null!==i&&"object"==typeof i){if(i[e])return i;if(i.then){var s=[];s.d=0,i.then((e=>{a[t]=e,r(s)}),(e=>{a[n]=e,r(s)}));var a={};return a[e]=e=>e(s),a}}var o={};return o[e]=e=>{},o[t]=i,o})))(i);var a=()=>h.map((e=>{if(e[n])throw e[n];return e[t]})),c=new Promise((t=>{(s=()=>t(a)).r=0;var n=e=>e!==o&&!l.has(e)&&(l.add(e),e&&!e.d&&(s.r++,e.push(s)));h.map((t=>t[e](n)))}));return s.r?c:a()}),(e=>(e?d(f[n]=e):c(u),r(o)))),o&&o.d<0&&(o.d=0)},a.d=(e,t)=>{for(var n in t)a.o(t,n)&&!a.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),a(927)})();